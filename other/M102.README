<owhite> would anyone have a suggested approach to allow me to make a
gcode call that passes a 6bit value to hal, and those bits are used to
set 6 bins to high or low?

<owhite> s/bins/pins/

<jepler> owhite: a M1xx script can execute 'halcmd sets' to set the
value on a signal that doesn't have a writer.

------------------------------------------------------
#!/bin/bash

echo "M102 $@"

sets () { if [ $2 -eq 0 ]; then halcmd sets $1 0; else halcmd sets $1 1; fi }

val=${1%.*}

echo $val
set -x
sets sig1 $((val & 1))
sets sig2 $((val & 2))
sets sig3 $((val & 4))
sets sig4 $((val & 8))
sets sig5 $((val & 16))
sets sig6 $((val & 32))
------------------------------------------------------

<jepler> owhite: I created bit signals 'sig1' ... 'sig6' (which could
be linked to whereever the value needs to go) and then I can
manipulate the signals with that script.  e.g., if I execute M102 P9,
then sig1 and sig4 are set TRUE, and the rest are FALSE

<jepler> owhite: the two tricky parts were these:

<jepler> val=${1%.*} # strip off the fractional part of the "P-number"


<jepler> and the "sets" function which has to turn any nonzero value
into "1", because 'halcmd sets whatever 37' doesn't work if 'whatever'
is a bit signal (only 0 or 1 are accepted)

<owhite> got it. and what language am I looking at -- its a shell script?

<BigJohnT> I was just going to ask that question...

<jepler> yes it's a shell script for the bash shell -- that's what the
first line (#!/bin/bash) means

<owhite> well yah I figured as much but isnt that 'sets' a halcmd?

<jepler> sets () { if [ $2 -eq 0 ]; then halcmd sets $1 0; else halcmd
sets $1 1; fi }

<jepler> this line creates a new shell command called "sets".  The
part inside the {} is what actually happens when bash encounters a
"sets" command

<owhite> okay.

<jepler> if it's "sets mumble 0" then the shell will actually run
"halcmd sets mumble 0"; if it's "sets mumble 39" then the shell will
actually run "halcmd sets mumble 1"

<jepler> that was one of the tricky parts :-P
